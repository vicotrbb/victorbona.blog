---
phase: 03-helm-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - chart/Chart.yaml
  - chart/values.yaml
autonomous: true

must_haves:
  truths:
    - "helm template renders valid Kubernetes manifests"
    - "Deployment targets correct image repository ghcr.io/vicotrbb/victorbona.blog"
    - "Health probes point to /api/health and /api/ready on port 3000"
    - "Resources requests and limits are configured"
    - "HPA scales 2-4 pods based on CPU utilization"
    - "PDB ensures at least 1 pod available during disruptions"
    - "No ingress resource rendered (Cloudflare Tunnel handles routing)"
  artifacts:
    - path: "chart/Chart.yaml"
      provides: "Blog-specific chart metadata"
      contains: "name: victorbona-blog"
    - path: "chart/values.yaml"
      provides: "Blog deployment configuration"
      contains: "ghcr.io/vicotrbb/victorbona.blog"
  key_links:
    - from: "chart/values.yaml"
      to: "chart/templates/deployment.yaml"
      via: "components.web configuration"
      pattern: "components:\\s+web:"
    - from: "chart/values.yaml"
      to: "Dockerfile (Phase 1)"
      via: "matching UID 1001 in podSecurityContext"
      pattern: "runAsUser: 1001"
---

<objective>
Configure the existing Helm chart template for deploying the victorbona.blog Next.js application to Kubernetes.

Purpose: Enable ArgoCD deployment with proper health probes, resource limits, HPA, and PDB configuration. Cloudflare Tunnel handles external access, so no ingress is needed.

Output:
- Customized Chart.yaml with blog-specific metadata
- Configured values.yaml with production-ready settings
- Verified chart rendering with helm template
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-helm-deployment/03-CONTEXT.md
@.planning/phases/03-helm-deployment/03-RESEARCH.md
@.planning/phases/01-container-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Chart.yaml metadata</name>
  <files>chart/Chart.yaml</files>
  <action>
Update Chart.yaml to reflect the blog application:

1. Change `name` from "app-template" to "victorbona-blog"
2. Update `description` to "Victor Bona's personal blog"
3. Keep `apiVersion: v2` and `type: application`
4. Keep `version: 0.1.0` and `appVersion: "0.1.0"`
5. Remove the `dependencies` section entirely (postgresql, redis, minio not needed)

The chart name change is cosmetic but helps identify the deployment in ArgoCD and helm list output.
  </action>
  <verify>
Run: `cat chart/Chart.yaml`
Confirm: name is "victorbona-blog", no dependencies section
  </verify>
  <done>Chart.yaml has blog-specific metadata with no unnecessary dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Configure values.yaml for blog deployment</name>
  <files>chart/values.yaml</files>
  <action>
Replace the entire values.yaml with blog-specific configuration. Use the complete configuration from 03-RESEARCH.md as the template.

Key configuration sections:

**global section:**
- nameOverride: "victorbona-blog"
- podSecurityContext: runAsUser/runAsGroup/fsGroup: 1001, runAsNonRoot: true
- securityContext: allowPrivilegeEscalation: false, drop ALL capabilities
- Note: readOnlyRootFilesystem: false (Next.js needs .next/cache write access)

**serviceAccount section:**
- create: true
- automountServiceAccountToken: false (blog doesn't need K8s API access)

**components.web section (rename from "api"):**
- enabled: true
- replicaCount: 2
- image.repository: ghcr.io/vicotrbb/victorbona.blog
- image.tag: "latest"
- ports: containerPort 3000, name "http"
- service: ClusterIP, port 80 -> targetPort http
- ingress.enabled: false (Cloudflare Tunnel handles routing)
- env vars: HOSTNAME="0.0.0.0", PORT="3000", NODE_ENV="production"
- resources: requests 128Mi/100m, limits 256Mi/200m
- livenessProbe: /api/health, port 3000, initialDelay 10s, period 10s, timeout 5s, failure 3
- readinessProbe: /api/ready, port 3000, initialDelay 5s, period 5s, timeout 3s, failure 3
- startupProbe: /api/health, port 3000, initialDelay 0, period 5s, failure 30 (150s max startup)
- autoscaling: enabled true, min 2, max 4, CPU 70%
- pdb: enabled true, minAvailable 1

**components.worker section:**
- enabled: false (no background worker needed)

**externalServices section:**
- All disabled (postgres, redis, minio)

**observability section:**
- otel.enabled: false (placeholder for Phase 4)
- otel.serviceName: "victorbona-blog"
- serviceMonitor.enabled: false (placeholder for Phase 5)

**Other sections:**
- networkPolicy.enabled: false
- postgresql.enabled: false
- redis.enabled: false
- minio.enabled: false

Add comments explaining key configuration choices, especially:
- Why ingress is disabled (Cloudflare Tunnel)
- Why readOnlyRootFilesystem is false (Next.js cache)
- That observability sections are placeholders for future phases
  </action>
  <verify>
Run: `helm template blog ./chart --debug 2>&1 | head -100`
Confirm: Deployment renders with correct image, probes, resources
Run: `helm template blog ./chart --show-only templates/deployment.yaml | grep -A5 "image:"`
Confirm: Image is ghcr.io/vicotrbb/victorbona.blog
Run: `helm template blog ./chart --show-only templates/hpa.yaml`
Confirm: HPA renders with minReplicas: 2, maxReplicas: 4
Run: `helm template blog ./chart --show-only templates/pdb.yaml`
Confirm: PDB renders with minAvailable: 1
Run: `helm template blog ./chart --show-only templates/ingress.yaml 2>&1`
Confirm: No ingress resource rendered (or empty output)
  </verify>
  <done>values.yaml fully configured with blog-specific settings; helm template renders valid manifests</done>
</task>

<task type="auto">
  <name>Task 3: Validate complete chart rendering</name>
  <files>chart/values.yaml, chart/Chart.yaml</files>
  <action>
Perform final validation of the Helm chart:

1. Run `helm lint ./chart` to check for chart issues
2. Run `helm template blog ./chart` and verify:
   - Deployment exists with correct container spec
   - Service exists with ClusterIP type
   - HPA exists targeting the deployment
   - PDB exists with minAvailable: 1
   - ServiceAccount exists
   - No Ingress resource rendered
   - No NetworkPolicy rendered
   - No external service resources (postgres/redis/minio)

3. Verify key deployment details:
   - Container runs as user 1001
   - HOSTNAME env var is set to "0.0.0.0"
   - All three probes configured (liveness, readiness, startup)
   - Resources have requests and limits

4. Verify no rendering errors or warnings

If any issues found, fix them and re-validate.
  </action>
  <verify>
Run: `helm lint ./chart`
Confirm: "0 chart(s) failed" in output
Run: `helm template blog ./chart | grep "kind:" | sort | uniq -c`
Confirm: Shows Deployment, HorizontalPodAutoscaler, PodDisruptionBudget, Service, ServiceAccount (5 resources)
Run: `helm template blog ./chart --show-only templates/deployment.yaml | grep "runAsUser"`
Confirm: Shows runAsUser: 1001
  </verify>
  <done>Helm chart passes linting and renders exactly 5 Kubernetes resources with correct configuration</done>
</task>

</tasks>

<verification>
## Overall Phase Verification

After all tasks complete:

1. **Chart metadata:** `cat chart/Chart.yaml | grep "name:"` shows "victorbona-blog"
2. **Image configuration:** `helm template blog ./chart --show-only templates/deployment.yaml | grep "image:"` shows ghcr.io/vicotrbb/victorbona.blog
3. **Health probes:** `helm template blog ./chart --show-only templates/deployment.yaml | grep -A2 "livenessProbe:"` shows httpGet to /api/health
4. **Resources:** `helm template blog ./chart --show-only templates/deployment.yaml | grep -A4 "resources:"` shows requests/limits
5. **HPA:** `helm template blog ./chart --show-only templates/hpa.yaml | grep "minReplicas"` shows 2
6. **PDB:** `helm template blog ./chart --show-only templates/pdb.yaml | grep "minAvailable"` shows 1
7. **No ingress:** `helm template blog ./chart 2>&1 | grep -c "kind: Ingress"` returns 0
8. **Lint passes:** `helm lint ./chart` shows 0 failures
</verification>

<success_criteria>
- Chart.yaml updated with name "victorbona-blog" and no dependencies
- values.yaml configured with all blog-specific settings
- helm lint passes with no errors
- helm template renders exactly 5 resources: Deployment, Service, HPA, PDB, ServiceAccount
- No Ingress resource rendered
- Deployment has correct image, probes, resources, and security context
- HPA configured for 2-4 replicas at 70% CPU
- PDB configured with minAvailable: 1
</success_criteria>

<output>
After completion, create `.planning/phases/03-helm-deployment/03-01-SUMMARY.md` following the summary template with:
- Frontmatter with phase, plan, subsystem (infra), tags, requires, provides, affects
- Performance metrics
- Files modified
- Key decisions
- Verification results
</output>
