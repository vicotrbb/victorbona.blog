---
phase: 05-prometheus-metrics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/lib/metrics.ts
  - app/metrics/route.ts
  - package.json
  - chart/values.yaml
autonomous: true

must_haves:
  truths:
    - "/metrics endpoint returns Prometheus text format"
    - "Node.js runtime metrics included (heap, event loop, GC)"
    - "ServiceMonitor enabled for Prometheus discovery"
    - "Metrics registry survives HMR in development"
  artifacts:
    - path: "app/lib/metrics.ts"
      provides: "Singleton metrics registry with default collectors"
      exports: ["metricsRegistry"]
    - path: "app/metrics/route.ts"
      provides: "GET handler for /metrics endpoint"
      exports: ["GET"]
    - path: "chart/values.yaml"
      provides: "Enabled metrics and ServiceMonitor configuration"
      contains: "metrics:\n      enabled: true"
  key_links:
    - from: "app/metrics/route.ts"
      to: "app/lib/metrics.ts"
      via: "import metricsRegistry"
      pattern: "from.*lib/metrics"
    - from: "app/metrics/route.ts"
      to: "metricsRegistry.metrics()"
      via: "async metrics collection"
      pattern: "await metricsRegistry\\.metrics\\(\\)"
    - from: "chart/values.yaml"
      to: "observability.serviceMonitor.enabled"
      via: "ServiceMonitor toggle"
      pattern: "serviceMonitor:\\s+enabled: true"
---

<objective>
Implement Prometheus metrics exposition for the Next.js blog.

Purpose: Enable Prometheus to scrape Node.js runtime metrics (heap, event loop, GC) for observability dashboards and alerting. This fulfills REQ-OBS-003 (Prometheus Metrics).

Output:
- `/metrics` endpoint returning Prometheus text format
- Default Node.js runtime metrics via prom-client
- ServiceMonitor enabled for automatic Prometheus discovery
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-prometheus-metrics/05-CONTEXT.md
@.planning/phases/05-prometheus-metrics/05-RESEARCH.md
@chart/values.yaml
@chart/templates/servicemonitor.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metrics module and route</name>
  <files>
    - app/lib/metrics.ts
    - app/metrics/route.ts
    - package.json
  </files>
  <action>
1. Install prom-client:
   ```bash
   npm install prom-client@^15.1.3
   ```

2. Create `app/lib/metrics.ts` - Singleton metrics registry:
   - Use globalThis pattern for HMR resilience (per RESEARCH.md)
   - Call `collectDefaultMetrics()` with registry
   - Set default label `app: 'victorbona-blog'` (per CONTEXT.md)
   - No custom prefix - use standard `nodejs_*` metric names
   - Export `metricsRegistry` as named export

3. Create `app/metrics/route.ts` - Route handler:
   - Import metricsRegistry from `../lib/metrics` (no @/ alias configured)
   - Export `dynamic = 'force-dynamic'` for cache control
   - Export async GET handler
   - Call `await metricsRegistry.metrics()` to collect
   - Return 200 with `Content-Type: text/plain; charset=utf-8`
   - Catch errors and return 503 Service Unavailable (per CONTEXT.md)

NOTE: Use `app/metrics/route.ts` NOT `app/api/metrics/route.ts` - this creates `/metrics` path which matches values.yaml configuration.
  </action>
  <verify>
    ```bash
    # Verify prom-client installed
    grep "prom-client" package.json

    # Build to check for TypeScript errors
    npm run build

    # Start dev server and test endpoint
    npm run dev &
    sleep 5
    curl -s http://localhost:3000/metrics | head -20

    # Verify Prometheus format (should see nodejs_* metrics)
    curl -s http://localhost:3000/metrics | grep -E "^nodejs_"

    # Kill dev server
    pkill -f "next dev" || true
    ```
  </verify>
  <done>
    - prom-client@^15.1.3 in package.json
    - `curl http://localhost:3000/metrics` returns Prometheus text format
    - Response contains `nodejs_heap_size_used_bytes` and other default metrics
    - Response contains `app="victorbona-blog"` label
    - No TypeScript errors on build
  </done>
</task>

<task type="auto">
  <name>Task 2: Enable Helm ServiceMonitor</name>
  <files>
    - chart/values.yaml
  </files>
  <action>
Update `chart/values.yaml` to enable metrics and ServiceMonitor:

1. Under `components.web.metrics`, change:
   ```yaml
   metrics:
     enabled: true          # Was: false
     portName: http
     path: /metrics
     interval: 30s
     scrapeTimeout: 10s
     scheme: http
     honorLabels: false
   ```

2. Under `observability.serviceMonitor`, change:
   ```yaml
   serviceMonitor:
     enabled: true          # Was: false
     labels: {}
     namespace: ""
   ```

The existing servicemonitor.yaml template already handles:
- Selector matching via selectorLabels helper
- Namespace selector from Release.Namespace
- Endpoint configuration from component metrics values
  </action>
  <verify>
    ```bash
    # Verify values.yaml changes
    grep -A 2 "metrics:" chart/values.yaml | head -5
    grep -A 2 "serviceMonitor:" chart/values.yaml | head -5

    # Template the chart to verify ServiceMonitor renders
    helm template test chart/ | grep -A 20 "kind: ServiceMonitor"
    ```
  </verify>
  <done>
    - `components.web.metrics.enabled: true` in values.yaml
    - `observability.serviceMonitor.enabled: true` in values.yaml
    - `helm template` produces valid ServiceMonitor resource
    - ServiceMonitor targets `/metrics` endpoint on port `http`
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

```bash
# Full build verification
npm run build

# Verify metrics endpoint works
npm run dev &
sleep 5
curl -s http://localhost:3000/metrics | head -30
pkill -f "next dev" || true

# Verify Helm chart renders correctly
helm template test chart/ --set observability.serviceMonitor.enabled=true | grep -A 30 "kind: ServiceMonitor"
```

Expected:
- Build succeeds without errors
- `/metrics` returns Prometheus text format with `nodejs_*` metrics
- ServiceMonitor resource renders with correct selector and endpoint config
</verification>

<success_criteria>
1. `/metrics` endpoint returns HTTP 200 with `text/plain` content type
2. Response contains default Node.js metrics:
   - `nodejs_heap_size_used_bytes`
   - `nodejs_eventloop_lag_seconds`
   - `process_resident_memory_bytes`
3. Response includes `app="victorbona-blog"` label on all metrics
4. `npm run build` succeeds
5. `helm template` produces ServiceMonitor resource
6. ServiceMonitor selector matches service labels
</success_criteria>

<output>
After completion, create `.planning/phases/05-prometheus-metrics/05-01-SUMMARY.md`
</output>
